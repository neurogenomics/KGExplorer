% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/0docs.R, R/plot_clinvar.R, R/plot_ggnetwork.R,
%   R/plot_graph_3d.R, R/plot_ontology.R, R/plot_ontology_circular.R,
%   R/plot_ontology_graphviz.R, R/plot_ontology_heatmap.R,
%   R/plot_ontology_tidygraph.R, R/plot_ontology_visnetwork.R, R/plot_save.R,
%   R/plot_upheno_heatmap.R
\name{plot_}
\alias{plot_}
\alias{plot_clinvar}
\alias{plot_ggnetwork}
\alias{plot_graph_3d}
\alias{plot_ontology}
\alias{plot_ontology_circular}
\alias{plot_ontology_graphviz}
\alias{plot_ontology_heatmap}
\alias{plot_ontology_tidygraph}
\alias{plot_ontology_visnetwork}
\alias{plot_save}
\alias{plot_upheno_heatmap}
\title{Plot functions}
\source{
\href{https://www.r-bloggers.com/2013/09/network-visualization-part-4-3d-networks/}{
R bloggers}

\href{https://community.plotly.com/t/is-it-possible-to-connect-scatters-in-3d-scatter-plot/}{
Plotly: Connect points in 3D plot}

\href{https://plotly.com/r/line-charts/}{
Plotly: Connect points in 2D plot}

\href{https://plotly.com/r/3d-line-plots/}{
Plotly: 3D lines plots}

\href{https://plotly.com/python/v3/3d-network-graph/}{
Plotly: 3D network plot}
}
\usage{
plot_clinvar(
  hits,
  x = "region",
  y = "N",
  fill = "Type",
  rows = "ClinSigSimple",
  by = c("build", x, fill, rows)
)

plot_ggnetwork(
  g,
  colour_var = "x",
  size_var = colour_var,
  label_var = "name",
  hoverbox_column = "hover",
  interactive = TRUE,
  show_plot = TRUE,
  ...
)

plot_graph_3d(
  g,
  layout_func = igraph::layout.fruchterman.reingold,
  id_var = "name",
  node_color_var = "ancestor_name",
  edge_color_var = "zend",
  text_color_var = node_color_var,
  node_symbol_var = "ancestor_name",
  node_palette = pals::kovesi.cyclic_mrybm_35_75_c68_s25,
  edge_palette = pals::kovesi.cyclic_mrybm_35_75_c68_s25,
  node_opacity = 0.75,
  edge_opacity = 0.5,
  kde_palette = pals::gnuplot,
  add_kde = TRUE,
  extend_kde = 1.5,
  bg_color = kde_palette(6)[1],
  add_labels = FALSE,
  keep_grid = FALSE,
  aspectmode = "cube",
  hover_width = 100,
  label_width = 100,
  seed = 2023,
  showlegend = TRUE,
  show_plot = TRUE,
  save_path = tempfile(fileext = "plot_graph_3d.html"),
  verbose = TRUE
)

plot_ontology(
  ont,
  terms = NULL,
  types = c("circular", "graphviz", "tidygraph", "visnetwork"),
  ...
)

plot_ontology_circular(ont, ...)

plot_ontology_graphviz(ont, ...)

plot_ontology_heatmap(
  ont,
  annot = data.table::data.table(ont@elementMetadata),
  X = ontology_to(ont, to = "similarity"),
  fontsize = ont@n_terms * 4e-04,
  row_labels = ont@terms,
  column_labels = row_labels,
  name = NULL,
  row_side_vars = c("ancestor_name"),
  col_side_vars = c("IC", "depth", "n_children", "n_offspring", "n_connected_leaves"),
  col = pals::gnuplot(),
  show_plot = TRUE,
  save_path = tempfile(fileext = "plot_ontology_heatmap.pdf"),
  height = 12,
  width = height * 1.1,
  seed = 2023,
  types = c("heatmaply", "ComplexHeatmap")[2],
  ...
)

plot_ontology_tidygraph(ont, ...)

plot_ontology_visnetwork(ont, ...)

plot_save(plt, save_path = save_path, width = NULL, height = width)

plot_upheno_heatmap(
  plot_dat,
  ont = get_ontology("upheno", add_ancestors = 10),
  hpo_ids = NULL,
  value.var = c("phenotype_genotype_score", "prop_intersect", "equivalence_score",
    "subclass_score"),
  name = value.var[1],
  min_rowsums = NULL,
  cluster_from_ontology = FALSE,
  save_dir = tempdir(),
  height = 15,
  width = 10
)
}
\arguments{
\item{g}{ggnetwork object 
(or an igraph/tbl_graph to be converted to ggnetwork format).}

\item{colour_var}{Column to color nodes by.}

\item{size_var}{Column to scale node size by.}

\item{label_var}{Column containing the label for each node in a graph
(e.g. "hpo_name").}

\item{interactive}{Make the plot interactive.}

\item{show_plot}{Print the plot after it's been generated.}

\item{...}{
  Arguments passed on to \code{\link[ggplot2:aes]{ggplot2::aes}}, \code{\link[simona:dag_viz]{simona::dag_circular_viz}}, \code{\link[simona:dag_viz]{simona::dag_graphviz}}, \code{\link[base:plot]{base::plot}}, \code{\link[simona:dag_viz]{simona::dag_graphviz}}
  \describe{
    \item{\code{dag}}{An \code{ontology_Dag} object.}
    \item{\code{highlight}}{A vector of terms to be highlighted on the DAG.}
    \item{\code{start}}{Start of the circle, measured in degree.}
    \item{\code{end}}{End of the circle, measured in degree.}
    \item{\code{partition_by_level}}{If \code{node_col} is not set, users can cut the DAG into clusters with different node colors. The partitioning is applied by \code{\link[simona:partition_by_level]{partition_by_level()}}.}
    \item{\code{partition_by_size}}{Similar as \code{partition_by_level}, but the partitioning is applied by \code{\link[simona:partition_by_size]{partition_by_size()}}.}
    \item{\code{node_col}}{Colors of nodes. If the value is a vector, the order should correspond to terms in \code{\link[simona:dag_all_terms]{dag_all_terms()}}.}
    \item{\code{node_transparency}}{Transparency of nodes. The same format as \code{node_col}.}
    \item{\code{node_size}}{Size of nodes. The same format as \code{node_col}.}
    \item{\code{edge_col}}{A named vector where names correspond to relation types.}
    \item{\code{edge_transparency}}{A named vector where names correspond to relation types.}
    \item{\code{legend_labels_from}}{If partitioning is applied on the DAG, a legend is generated showing different top
terms. By default, the legend labels are the term IDs. If there are additionally column stored
in the meta data frame of the DAG object, the column name can be set here to replace the term IDs as
legend labels.}
    \item{\code{legend_labels_max_width}}{Maximal width of legend labels measured by the number of characters per line. Labels are wrapped into
multiple lines if the widths exceed it.}
    \item{\code{other_legends}}{A list of legends generated by \code{\link[ComplexHeatmap:Legend]{ComplexHeatmap::Legend()}}.}
    \item{\code{use_raster}}{Whether to first write the circular image into a temporary png file, then add to the plot
as a raster object?}
    \item{\code{newpage}}{Whether call \code{\link[grid:grid.newpage]{grid::grid.newpage()}} to create a new plot?}
    \item{\code{node_param}}{A list of parameters. Each parameter has the same format. The value can be
a single scalar, a full length vector with the same order as in \code{\link[simona:dag_all_terms]{dag_all_terms()}},
or a named vector that contains a subset of terms that need to be customized.
The full set of parameters can be found at \url{https://graphviz.org/docs/nodes/}.}
    \item{\code{edge_param}}{A list of parameters. Each parameter has the same format. The value can be a single
scalar, or a named vector that contains a subset of terms that need to be customized.
The full set of parameters can be found at \url{https://graphviz.org/docs/edges/}.
If the parameter is set to a named vector, it can be named by relation types \code{c("is_a" = ...)},
or directly relations \code{c("a -> b" = ...)}. Please see the vignette for details.}
    \item{\code{x}}{the coordinates of points in the plot. Alternatively, a
      single plotting structure, function or \emph{any \R object with a
        \code{plot} method} can be provided.}
    \item{\code{y}}{the y coordinates of points in the plot, \emph{optional}
    if \code{x} is an appropriate structure.}
  }}

\item{layout_func}{Layout function for the graph.}

\item{node_color_var}{Variable in the vertex metadata to color nodes by.}

\item{edge_color_var}{Variable in the edge metadata to color edges by.}

\item{text_color_var}{Variable in the node metadata to color text by.}

\item{node_symbol_var}{Variable in the vertex metadata to shape nodes by.}

\item{node_palette}{Color palette function for the nodes/points.}

\item{edge_palette}{Color palette function for the edges/lines.}

\item{node_opacity}{Node opacity.}

\item{edge_opacity}{Edge opacity.}

\item{kde_palette}{Color palette function for the KDE plot.}

\item{add_kde}{Add a kernel density estimation (KDE) plot
below the 3D scatter plot (i.e. the "mountains" beneath the points).}

\item{extend_kde}{Extend the area that the KDE plot covers.}

\item{bg_color}{Plot background color.}

\item{add_labels}{Add phenotype name labels to each point.}

\item{keep_grid}{Keep all grid lines and axis labels.}

\item{aspectmode}{The proportions of the 3D plot. See the
\href{https://plotly.com/python/reference/layout/scene/#layout-scene-aspectmode}{
plotly documentation site} for details.}

\item{hover_width}{Maximum width of the hover text.}

\item{label_width}{Maximum width of the label text.}

\item{seed}{Set the seed for reproducible clustering.}

\item{showlegend}{Show node fill legend.}

\item{save_path}{Path to save interactive plot to
as a self-contained HTML file.}

\item{verbose}{Print messages.}

\item{ont}{An ontology of class \link[simona]{ontology_DAG}.}

\item{terms}{A vector of ontology term IDs.}

\item{types}{Types of graph to produce. Can be one or more.}

\item{fontsize}{Axis labels font size.}

\item{row_labels}{Optional row labels which are put as row names in the heatmap.}

\item{column_labels}{Optional column labels which are put as column names in the heatmap.}

\item{name}{Name of the heatmap. By default the heatmap name is used as the title of the heatmap legend.}

\item{row_side_vars}{Variables to include in row-side
metadata annotations.}

\item{col_side_vars}{Variables to include in column-side
metadata annotations.}

\item{col}{A vector of colors if the color mapping is discrete or a color mapping  function if the matrix is continuous numbers (should be generated by \code{\link[circlize]{colorRamp2}}). If the matrix is continuous, the value can also be a vector of colors so that colors can be interpolated. Pass to \code{\link[ComplexHeatmap]{ColorMapping}}. For more details and examples, please refer to \url{https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#colors} .}

\item{height}{Height of the heatmap body.}

\item{width}{Width of the heatmap body.}

\item{save_dir}{Directory to save a file to.}

\item{id_col}{Column containing the unique identifier for each node 
in a graph (e.g. "name").}

\item{top_targets}{\link[data.table]{data.table} of prioritised targets
generated by \link[MultiEWCE]{prioritise_targets}.}
}
\value{
A named list containing the plot and the data.

A 3D interactive \link[plotly]{plotly} object.

Null

Null

Plot

Null

Null
}
\description{
Functions to plot data.
}
\section{Functions}{
\itemize{
\item \code{plot_clinvar()}: plot_
Plot mapped variant annotations.

\item \code{plot_ggnetwork()}: plot_
Plot a ggnetwork.

\item \code{plot_graph_3d()}: plot_
3D network

Plot a subset of the HPO as a 3D network.

\item \code{plot_ontology()}: plot_

\item \code{plot_ontology_circular()}: plot_

\item \code{plot_ontology_graphviz()}: plot_
Plot ontology: graphviz

Make a circular plot of an ontology.

\item \code{plot_ontology_heatmap()}: plot_
Plot heatmap

Plot a phenotype x phenotype correlation matrix based on genetic overlap.

\item \code{plot_ontology_tidygraph()}: plot_

\item \code{plot_ontology_visnetwork()}: plot_

\item \code{plot_save()}: plot_
Save a plot using \link[ggplot2]{ggsave}, \pkg{grDevices},
 or \link[visNetwork]{visSave}.

\item \code{plot_upheno_heatmap()}: plot_

}}
\examples{
ont <- get_ontology(terms=10)
g <- ontology_to(ont, to="tbl_graph")
g <- add_hoverboxes(g)
out <- plot_ggnetwork(g, label_var="label")
ont <- get_ontology("hp", terms=10, add_ancestors=TRUE)
g <- ontology_to(ont, to="tbl_graph")
plt <- plot_graph_3d(g=g, show_plot=FALSE)
ont <- get_ontology("hp")
res <- plot_ontology(ont, 
                     terms=100,
                     types="circular",
                     partition_by_level=2,
                     edge_transparency=.9)
ont <- get_ontology("hp", terms=2)
hm <- plot_ontology_heatmap(ont)
}
\concept{plot_}
\keyword{internal}
